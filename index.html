<!DOCTYPE HTML>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
        <title>JavaScript Garden</title>
        <link rel="stylesheet" href="garden.css" type="text/css" media="screen" charset="utf-8">
    </head>

    <body id="top">
        <div id="nav"><h1>The Shed</h1><div id="navbox"><div><a href="#objects">Objects</a></div><div><a href="#the-prototype">The Prototype</a></div><div><a href="#hasownproperty">hasOwnProperty</a></div><div><a href="#the-for-in-loop">The For In Loop</a></div><div><a href="#arrays">Arrays</a></div><div><a href="#the-array-constructor">The Array Constructor</a></div><div><a href="#functions-and-closures">Functions and Closures</a></div><div><a href="#function-arguments">Function Arguments</a></div><div><a href="#pass-by-value-and-references">Pass By Value and References</a></div><div><a href="#more-on-scopes">More on Scopes</a></div><div><a href="#expressions-and-statements">Expressions and Statements</a></div><div><a href="#how-this-works-in-javascript">How this works in JavaScript</a></div><div><a href="#constructors">Constructors</a></div><div><a href="#the-typeof-operator">The typeof operator</a></div><div><a href="#the-instanceof-operator">The instanceof operator</a></div><div><a href="#equality-in-javascript">Equality in JavaScript</a></div><div><a href="#null-and-undefined">Null and Undefined</a></div><div><a href="#automatic-semicolon-insertion">Automatic Semicolon Insertion</a></div></div><div id="footer"><p>Copyright (c) 2011 Ivo Wetzel</p></div> </div>
        <div id="main"><h1>JavaScript Garden</h1><p><strong>JavaScript Garden</strong> is a collection of documentation about the most quirky
parts of the JavaScript language. </p><h3 class="section" id="objects">Objects<a href="#top">^</a></h3><div class="sub"><p>To make it short, everything in JavaScript <em>acts</em> like an <code>Object</code>, expect for 
<code>null</code> and <code>undefined</code>. This means that all those values inherit from 
<code>Object.prototype</code> (yet another reason <strong>not</strong> to mess with it).</p>

<p><strong>Examples</strong></p>

<pre><code>false.toString() // 'false'
[1, 2, 3].toString(); // '1,2,3'
</code></pre>

<p><strong>Common Mistakes</strong></p>

<pre><code>2.toString(); // syntax error
</code></pre>

<p>The above doesn't work, but this is <strong>not</strong> because of the number not being an
object (in fact JavaScript interprets it as an Object just fine), but a 
mis-design in JavaScript's parser. Which tries to parse <em>anything</em> that follows a
dot - which itself is preceded by whitespace or a number -  as a float.</p>

<p>You can work around this by either inserting a space <code>2. toString()</code> or using
parenthesis <code>(2).toString()</code>.</p>

<p>Objects can also <em>act</em> like a hashmap in JavaScript by simply mapping <em>keys</em> to
<em>values</em>. Using the curly brace notation <code>{}</code> one can create a new plain object, 
which inherits from <code>Object</code> and has no <em>own properties</em>.</p>

<p><strong>Examples</strong></p>

<pre><code>var foo = {}; // a new empty object
var bar = {test: 12}; // a new object which has one property called 'test'
                      // which value is 12
</code></pre>

<p><strong>Common Mistakes</strong></p>

<pre><code>var foo = {
    delete: function() {} // syntax error
};
</code></pre>

<p>The above does not work in JavaScript engines which do not support EcmaScript 5.
What happens is that <code>delete</code> is a <em>keyword</em> and therefore cannot be used as a key
here. But you can simply work around this by using a string with the value
<code>'delete'</code> instead of the plain token.</p>

<p>This is yet another mis-design in JavaScript's parser that you to watch out for.</p></div><h3 class="section" id="the-prototype">The Prototype<a href="#top">^</a></h3><div class="sub"><p>JavaScript does not feature classical inheritance, but it has prototypical one.</p>

<p><strong>In short:</strong> JavaScript's Model is more powerful (you can for example implement 
classical inheritance with it, you can't do this the other way around), but also 
more error prone.</p>

<p>Common mistakes arise from the fact how the prototype chain works.</p>

<p><strong>Examples</strong></p>

<pre><code>function Foo() {
    this.value = 42;
}
Foo.prototype = {
    method: function() {
    }
};

function Bar() {
}

// Set Bar's prototype to the prototype object of Foo
Bar.prototype = Foo.prototype;

var test = new Bar() // create a new bar instance
</code></pre>

<p>The above <code>test</code> object will inherit from both <code>Bar.prototype</code> and
<code>Foo.prototype</code> so it will have access to the function <code>method</code> that was defined
on <code>Foo</code>, but it will not have access to the value property of a <code>Foo</code> instance
since <code>Foo</code> itself never gets called.  </p>

<p><strong>Note:</strong> Don't use <code>Bar.property = Foo;</code> this will <strong>no</strong>t point to <code>Foo</code>'s
prototype but rather to the function object <code>Foo</code>, so the chain will go over
<code>Function.prototype</code> in this case.</p>

<p>If you try to access a property of an object, JavaScript will search the
prototype chain <strong>upwards</strong> until it finds a property with the specified name,
when it reaches the top of the chain, namely <code>Object.prototype</code>, and still
hasn't found the property it will return <code>undefined</code>.</p>

<p><strong>The Prototype Chain in the above Example</strong></p>

<pre><code>Object.prototype: {toString: ... /* etc. */};
    Foo.prototype: {method: ...};
        Bar.prototype: Foo.prototype
            Bar.method()
</code></pre>

<p><strong>Note:</strong> You can assign <em>any</em> <code>object</code> to the prototype value, so consider
the following:</p>

<pre><code>Bar.prototype = new Foo();
var boo = new Bar();
</code></pre>

<p><strong>The resulting prototype chain</strong></p>

<pre><code>Object.prototype: {toString: ... /* etc. */};
    Foo.prototype: {method: ...};
        [Foo Instance]: {value: 42};
            Bar.prototype: [Foo Instance]
                Bar.method()
</code></pre>

<p>Now <code>Bar.prototype</code> points to an <strong>instance</strong> of <code>Foo</code>, which of course is just
another object, but this time has the <code>value</code> property on it. And since <code>Foo</code>
itself has a prototype, the chain continues with that one afterwards.</p>

<p>All of this has a couple of implications:</p>

<ol>
<li>Having long prototype chains decreases performance due to many lookups</li>
<li>This can be used as a replacement of the classical inheritance model </li>
<li>You can't just access a property to check whether it's defined on a specific
object, since JS will always search the prototype chain upwards</li>
</ol>

<p><strong>Best Pratice:</strong> Make sure to watch you prototype chains, don't abuse them or
you will end up with strange bugs and/or horrible performance.</p></div><h3 class="section" id="hasownproperty">hasOwnProperty<a href="#top">^</a></h3><div class="sub"><p>If you want to check whether a object a property defined on <em>itself</em>, you have to 
use the <code>hasOwnProperty</code> method which all objects inherit from <code>Object.prototype</code>.</p>

<p>While it's tempting to just do a <code>Foo.bar !== undefined</code> this is in no way safe.
While JavaScript does return <code>undefined</code> for non-existent properties, they
property might very well exist, but it's value is set to <code>undefined</code>.</p>

<p>Also using the <code>in</code> operator doesn't work either, since it <em>does</em> traverse the
prototype chain upwards until it finds a property with the specified name.</p>

<p><strong>Examples</strong></p>

<pre><code>// Poisoning Object.prototype, NEVER do this
Object.prototype.bar = 1; 
var foo = {goo: undefined};

foo.bar; // 1
'bar' in foo; // true

foo.hasOwnProperty('bar'); // false
foo.hasOwnProperty('goo'); // true
</code></pre>

<p>As you can see, only <code>hasOwnProperty</code> gives the correct answer, the method is of
essential use when iterating over the properties of any object, since there's no
other way to exclude things that are not defined on the object itself but rather
somewhere on it's prototype chain.</p>

<p><strong>Best Practice:</strong> Always use <code>hasOwnProperty</code> when checking for properties on
objects.</p></div><h3 class="section" id="the-for-in-loop">The For In Loop<a href="#top">^</a></h3><div class="sub"><p>Just like the <code>in</code> operator, the <code>for in</code> loop does also traverse the prototype
chain when iterating over an object's properties. Although it will <em>not</em> include
properties that have their <code>enumerable</code> attribute set to false e.g. the <code>length</code>
property of an array.</p>

<p>So as you can already imagine you have to use <code>hasOwnProperty</code> in order to make
the iteration over an object's own properties work. Also, since <code>for in</code>
iterates over <em>anything</em> that's on the prototype chain, it will get slower for
more complex cases of inheritance.</p>

<p><strong>Broken Example</strong></p>

<pre><code>Object.prototype.bar = 1; // poisoning the Object.prototype, NEVER do this
var foo = {moo: 2};
for(var i in foo) {
    console.log(i);
}
</code></pre>

<p>This results in both <code>bar</code> and <code>moo</code> being printed out.</p>

<p><strong>Fixed Version</strong></p>

<pre><code>for(var i in foo) { // still the foo from above
    if (foo.hasOwnProperty(i)) {
        console.log(i);
    }
}
</code></pre>

<p>This version is the <strong>correct</strong> one, it will <em>only</em> print <code>moo</code>. If you don't use 
<code>hasOwnProperty</code>, your code is prone to errors when the native prototypes have
been extended.</p>

<p>For example the <code>Prototype.js</code> JavaScript Framework <strong>does</strong> do extend the 
prototypes of built in objects. So if your code ever ends up on a page which 
includes it (Hint: Ruby on Rails defaults to Prototype.js) and you're not using 
<code>hasOwnProperty</code>, all hell will break loose.</p>

<p><strong>Best Practice:</strong> Always use <code>hasOwnProperty</code> never make any assumptions on the
built in prototypes being extended or not.</p></div><h3 class="section" id="arrays">Arrays<a href="#top">^</a></h3><div class="sub"><p>Many people, coming from other languages or not, think that since
Arrays are objects too, they can use just the <code>For In</code> loop to iterate over them.</p>

<p>Whatever you do, do <strong>NOT</strong> do this. Even though the internals of JavaScript
make this work, it's horrible slow, and not only that, you have you to use 
<code>hasOwnProperty</code> too, to make sure you only get the stuff you want.</p>

<p>While one might think that it's a no brainer to trade a small performance loss
against readability, let me say that were not talking about small losses here.</p>

<p>We're talking about a factor of <strong>10x</strong> to <strong>20x</strong> here, depending on which engine, 
its version and how many properties there are defined on the array. </p>

<p>Also if you just want to iterate over a subset of an array, then using <code>For In</code> 
with an additional <code>if</code> condition is obviously not the way to go.</p>

<p>So how to do iteration over arrays in JavaScript? Well there's only one way
here, and that is to use the classic <code>for loop</code> (with one little extra).</p>

<p><strong>Example</strong></p>

<pre><code>var list = [1, 2, 3, 4, 5, ...... 100000000];
for(var i = 0, l = list.length; i &lt; l; i++) {
    console.log(list[i]);
}
</code></pre>

<p>The <code>l = list.length</code> part is used to cache the length of the array, because 
property look ups are <strong>slow</strong>.</p>

<p>The <code>length</code> property of an array is also special. It's <code>getter</code> just returns the
number of elements in the array. But it also has a <code>setter</code> which can be used to
<em>truncate</em> the array.</p>

<p><strong>Example</strong></p>

<pre><code>var foo = [1, 2, 3, 4, 5, 6];
foo.length = 3;
foo; // [1, 2, 3]
foo.length = 6;
foo; // [1, 2, 3]
</code></pre>

<p>As one can see, assigning a smaller length truncates the array but increasing it 
has no effect on the array whatsoever.</p>

<p>But back to caching the length, while newer JavaScript engines are able to
optimize the access to the <code>length</code> property, there are still cases where <em>not</em>
caching the length results in a loop that's up to <strong>2x</strong> slower then the version that
does the caching.</p>

<p><strong>Best Pratice:</strong> Always use the classical <code>for</code> loop and cache the length to
archieve the best performance, don't make any assumptions about the  engine your 
code will be running on.</p></div><h3 class="section" id="the-array-constructor">The Array Constructor<a href="#top">^</a></h3><div class="sub"><p>Always use the <code>[]</code> notation to create a new array, the Array constructor has
a horrible flaw in what kind of arguments it takes.</p>

<p><strong>Example</strong></p>

<pre><code>[1, 2, 3]; // New array with three elements
new Array(1, 2, 3); // Same as above

[9]; // New array with one element
new Array(9); // New array of length 9 filled with `undefined`
</code></pre>

<p>When there's only one argument being passed to the constructor it will create
a new array of that size, if you don't know this, things will explode</p>

<p>There are only a few cases when single parameter constructor comes in handy, on
of them is to repeat a string:</p>

<pre><code>new Array(count - 1).join(stringToRepeat);
</code></pre>

<p><strong>Best Practice:</strong> Always use the <code>[]</code> notation, it's cleaner and less error
prone.</p></div><h3 class="section" id="functions-and-closures">Functions and Closures<a href="#top">^</a></h3><div class="sub"><p>Functions in JavaScript are, yet again, Objects. This makes them extremely
powerful, you can for example, pass them around as parameters to provide 
callbacks to other methods.</p>

<p>But what really makes them powerful is the fact that JavaScript supports
<strong>Closures</strong>.</p>

<p>Closures mean that scopes <em>always</em> have access to the outer scope they were
defined in, and since JavaScript only has one type of scope, namely the function
one, one can use them to great good.</p>

<p><strong>The Classic "private" Example</strong></p>

<pre><code>function Counter(start) {
    var count = start;
    return {
        increment: function() {
            count++;
        },

        get: function() {
            return count;
        }
    }
}

var foo = new Counter(4);
foo.increment();
foo.get(); // 5
</code></pre>

<p>In the above example we return <strong>two closures</strong>, both the function <code>increment</code>
as well as <code>get</code> keep a reference to the <code>count</code> variable defined in the
constructor.</p>

<p>One <strong>cannot</strong> access <code>count</code> from the outside, the only way to interact with it
is via the two "closured" functions.</p>

<p>Remember, closures work by keeping a reference to their outer scopes, so the
following does <strong>not</strong> work:</p>

<pre><code>var foo = new Counter(4);
foo.hack = function() {
    count = 1337;
};
</code></pre>

<p>This will <strong>not</strong> change the variable <code>count</code> that's inside of <code>Counter</code> since 
<code>foo.hack</code> was not defined in that scope, instead, it will create or override the
global variable <code>count</code>.</p>

<p><strong>Best Practice:</strong> Keep in mind that every time you return a function it's
already a closure, you can use this to hide away internals or as in the above
example, use it to emulate private variables.</p></div><h3 class="section" id="function-arguments">Function Arguments<a href="#top">^</a></h3><div class="sub"><p>Inside a JavaScript function you have access to a special variable called
<code>arguments</code>, this is useful when writing functions that take a variable number
of arguments. While one might think that this is just a normal <code>Array</code> containing
the arguments that were passed to the function, but it's not.</p>

<p>The <code>arguments</code> <code>Object</code> kinda works like an <code>Array</code> but does not inherit from
<code>Array.prototype</code> so while it has a <code>length</code> property and you can use it with
a normal <code>for</code> loop, it does <strong>not</strong> have methods like <code>slice</code>, <code>push</code>, <code>pop</code>
etc.</p>

<p>If you need to have <code>arguments</code> work like a <em>real</em> <code>Array</code> you need to convert
it: </p>

<pre><code>Array.prototype.slice.call(arguments);
</code></pre>

<p>This will return a new <code>Array</code> containing all the elements from the <code>arguments</code>
<code>Object</code>.</p></div><h3 class="section" id="pass-by-value-and-references">Pass By Value and References<a href="#top">^</a></h3><div class="sub"><p>One common pitfall with closures is, that while all values in JavaScript are 
<strong>passed by value</strong>, closures keep <strong>references</strong>.</p>

<p><strong>Example</strong></p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout(function() {
        console.log(i);  
    }, 1000);
}
</code></pre>

<p>A common misconception is that the above will output the numbers <code>0</code> through
<code>9</code> after one second. But in reality, the above simply alerts the number <code>10</code> ten
times.</p>

<p>Remember, closures keep references, so this makes sense, since <code>i</code> is
a reference and at the time the timeouts fire, the loop has already finished and
updated the value of <code>i</code> to <code>10</code>.</p>

<p>So in order to fix it, you have to create a copy of the value of <code>i</code>. Don't
bother with another variable inside the loop, its value will just as well get
overridden. The trick here is to use an anonymous wrapper.</p>

<p><strong>Example</strong></p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    (function(e) {
        setTimeout(function() {
            console.log(e);  
        }, 1000);
    })(i);
}
</code></pre>

<p>Here the outer function gets called immediately with <code>i</code> (which is passed by 
value) as its parameter, therefore we now have a copy of the <em>current</em> value of 
<code>i</code> named <code>e</code> inside the function, which then gets referenced by our "closured"
function that gets passed to <code>setTimeout</code>.</p></div><h3 class="section" id="more-on-scopes">More on Scopes<a href="#top">^</a></h3><div class="sub"><p>JavaScript has <em>only</em> function scope, there's <strong>no</strong> block scope (although the
language deals fine with the usual syntax for blocks.).</p>

<p>Additionally, there are no distinct namespaces in JavaScript, this means that 
everything gets defined in <strong>one</strong> globally shared namespace.</p>

<p>Each time you reference a variable, JavaScript will search the scopes upwards
until it finds it, if it reaches the global scope and still can't find the
requested name it will raise a <code>ReferenceError</code>.</p>

<p>If you want to declare a variable local to the current scope you have to use the
<code>var</code> keyword. <strong>Always</strong> use the <code>var</code> keyword when declaring variables
otherwise you might override things that were already defined in the outer
scopes, which is <em>bad</em>.</p>

<p><strong>Example</strong></p>

<pre><code>var foo = 1; // global variable foo
var bar = 2; // global variable bar

function test() {
    var foo = 3; // NEW local variable foo, does NOT affect the global foo
    bar = 4; // we just changed the value of the outer bar
}
</code></pre>

<p>Now as you might already imagine, having only one global scope makes namespace 
clashes <em>more</em> than likely.</p>

<p>But there's a simply way to avoid this, you can use an <em>anoynmous</em> function
wrapper (we've already seen on of them them in the for loop example above).</p>

<p><strong>Example</strong></p>

<pre><code>(function() {
    // a self contained "namespace"

    window.foo = function() {
        // an exposed closure
    };

})(); // execute the function immediately
</code></pre>

<p>By default you cannot just call a function, you need to <em>evaluate</em> it first, in
this example this is done by wrapping the <em>function expression</em> in parenthesis.
This is the most common style to do this, but everything else that forces the
function to be evaluated works just as well, like for example <code>+function(){}()</code>.</p>

<p><strong>Best Practice:</strong> Always use the anonymous wrapper to encapsulate your code in
case there's any chance it might get used by someone else in their project. 
Also never define any variables in the global namespace, always use <code>var</code> to
limit the scope of your variables.</p></div><h3 class="section" id="expressions-and-statements">Expressions and Statements<a href="#top">^</a></h3><div class="sub"><p>In JavaScript there's a important difference between expressions and statements.</p>

<p><strong>Example</strong></p>

<pre><code>foo(); // this works just like expected
function foo() {}                    

bar(); // this raises a TypeError
console.log(bar); // No ReferenceError but prints 'undefined'
var bar = function() {}
</code></pre>

<p>In the above example the call to <code>foo</code> works due to the fact that <code>function
foo()</code> is a <em>statement</em>, but the call to <code>bar</code> fails since <code>var bar
= function()</code> is an <em>expression</em>.</p>

<p>Before the code is run, JavaScript executes all <em>statements</em>, since <code>var</code> is
a statement, the variable <code>bar</code> will get created but the corresponding
assignment expression will not yet get evaluated, therefore <code>bar</code> defaults to
the value of <code>undefined</code>.</p>

<p><strong>Another Example</strong></p>

<pre><code>function test() {
    if (foo) {
        bar = 2;

    } else {
        var bar = 1;
    }
    return foo;
}

if (false) {
    var foo = 1;
}
</code></pre>

<p>Remember, there's <strong>no</strong> block scope in JavaScript, therefore the above will
<em>not</em> assign <code>2</code> to the global variable <code>bar</code> but to the local <code>bar</code> of <code>test</code>.
Also, while the if body never gets executed, the variable <code>foo</code> still gets
created and defaults to <code>undefined</code>.</p></div><h3 class="section" id="how-this-works-in-javascript">How this works in JavaScript<a href="#top">^</a></h3><div class="sub"><p><code>this</code> in JavaScript is different from other languages, so many people get 
confused by it, but there are only three different cases in which the value of
<code>this</code> gets set.</p>

<pre><code>// function case
foo(); // this inside foo will refer to the global object

// method case
test.foo(); // this inside foo will refer to test

// constructor case
new foo(); // this inside foo will refer to the newly created object
</code></pre>

<p>These are <strong>all</strong> the possible values of <code>this</code>, it also gets clear that <code>this</code>
will never refer to an outer function, due to the implicit binding to the
<code>global</code> object in case of a plain function call.</p>

<p><strong>Example</strong></p>

<pre><code>Foo.method = function() {
    function test() {
        console.log(this); // this is set to the global object
    }
    test();
}
</code></pre>

<p>Another common misconception is that something like this would work:</p>

<pre><code>var str = 'Hello World';
var ord = str.charCodeAt;

var out = '';
for(var i = 0, l = str.length; i &lt; l; i++) {
    out += String.fromCharCode(ord(i));
}
console.log(out); // prints the string represanation of the global object
</code></pre>

<p>Since the value of <code>this</code> never gets determined <em>before</em> the actual call, the
above call to <code>ord</code> will work like a plain function call. Therefore <code>charCodeAt</code> 
will not use the string <code>Hello World</code>, but the results of calling <code>toString()</code> 
on the <code>global</code> object.</p>

<p>The late binding of <code>this</code> might seem like a bad thing but in fact it is what
makes the prototypical inheritance work. The only <strong>real</strong> problem here is the
implicit setting of <code>this</code> to the <code>global</code> object when doing a plain function
call, which is never of any use.</p></div><h3 class="section" id="constructors">Constructors<a href="#top">^</a></h3><div class="sub"><p>Constructors in JavaScript are another thing many people get wrong, their
workings are pretty simple though.</p>

<p>Any function call that's preceded by the <code>new</code> keyword acts as a constructor.</p>

<p>Inside the constructor (the called function) the value of <code>this</code> refers to a 
newly create object. The <code>prototype</code> of this new object is set to the <code>prototype</code>
of the function object that was called.</p>

<p>If the function that was called has no explicit <code>return</code> statement, then it
implicitly returns the value of <code>this</code> (the new object). Otherwise it returns
the value of the <code>return</code> statement.</p>

<p><strong>Example</strong></p>

<pre><code>function Foo() {
    this.bla = 1;
}
Foo.prototype.test = function() {
    console.log(this.bla);
};

var test = new Foo();
</code></pre>

<p>The above calls <code>Foo</code> as constructor and sets the <code>prototype</code> of the newly
created object to <code>Foo.prototype</code>.</p>

<p><strong>Another Example</strong></p>

<pre><code>function Bar() {
    var value = 1;
    return {
        method: function() {
            return value;
        }
    }
}

new Bar();
Bar();
</code></pre>

<p>Now, both these calls return the exact same thing, a newly create object which
has a property called <code>method</code> which is a closure.</p>

<p>Since <code>Bar</code> doesn't make any use of <code>this</code> the <code>new</code> keyword is superfluous in
this case. While the call with <code>new</code> can clearly be called constructor, the 
latter one works more like a factory.</p>

<p><strong>Best Practice:</strong> Make sure you know whether the <code>constructor</code> you're calling
requires the <code>new</code> keyword. Since there's no side effect of using <code>new</code> for 
factories you can use <code>new</code> for both. But in the end you should always test your 
code to prevent such subtle mistakes.</p></div><h3 class="section" id="the-typeof-operator">The typeof operator<a href="#top">^</a></h3><div class="sub"><p>To make it short, both <code>typeof</code> and <code>instanceof</code> are near to being 
<strong>completely broken</strong>, although <code>instanceof</code> still has its limited uses, 
but first let's take a look at this nice table:</p>

<pre><code>Value               Class      Type
-------------------------------------
"foo"               String     string
new String("foo")   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function("")    Function   function
/abc/g              RegExp     object (function in Nitro/V8)
new RegExp("meow")  RegExp     object (function in Nitro/V8)
{}                  Object     object
new Object()        Object     object
</code></pre>

<p>In the above table <code>Type</code> refers to the value the <code>typeof</code> operator returns. As
you can see this is anything but consistent.</p>

<p>The value of <code>Class</code> refers to the <em>internal [[Class]] property</em> of an object
(see the EcmaScript specification for more details.).</p>

<p>According to the specification <code>Class</code> can be one of the following values:  </p>

<pre><code>"Arguments", "Array", "Boolean", "Date", "Error", "Function", "JSON", 
"Math",  "Number", "Object", "RegExp", "String"
</code></pre>

<p>The following function can be used to check the type of an object:</p>

<pre><code>function is(type, obj) {
    return Object.prototype.toString.call(obj).slice(8, -1) === type;
}

is('String', 'test'); // true
is('String', new String('test')); // true
</code></pre>

<p>So before you set up your build tool and pre commit hooks to warn you about 
every occurrence of <code>typeof</code>, let me tell you that there is actually one 
<strong>and only one</strong> legitimate use for it:</p>

<pre><code>typeof foo !== 'undefined'
</code></pre>

<p>The above will check whether <code>foo</code> was actually declared or not, since just 
referencing it would result in a <code>ReferenceError</code>. But besides that, there's no
good use for <code>typeof</code>.</p>

<p><strong>Best Practice:</strong> If you're dealing with built in types, always use the <code>Class</code> 
value. It's the only <em>reliable</em> and cross engine way of getting the type of an 
object.</p></div><h3 class="section" id="the-instanceof-operator">The instanceof operator<a href="#top">^</a></h3><div class="sub"><p><code>instanceof</code> is only useful when comparing custom made objects, besides that it
returns a mess much like the <code>typeof</code> operator.</p>

<p><strong>Example</strong></p>

<pre><code>// Comparing custom objects
function Foo() {}
function Bar() {}
Bar.prototype = Foo;

new Bar() instanceof Bar; // true
new Bar() instanceof Foo; // false

// More mess
new String('foo') instanceof String; // true
new String('foo') instanceof Object; // true
'foo' instanceof String; // false
'foo' instanceof Object; // false
</code></pre>

<p>Of course <code>instanceof</code> does not work cross document wise since the objects were
created in different contexts.</p>

<p><strong>Best Practice:</strong> Only use <code>instanceof</code> when dealing with custom made objects
and keep its limitations in mind.</p></div><h3 class="section" id="equality-in-javascript">Equality in JavaScript<a href="#top">^</a></h3><div class="sub"><p>JavaScript has two different ways of comparing the values of objects. For one it
has the <code>==</code> equal operator and then there is the <code>===</code> equal operator.</p>

<p>There is an important difference why you should <strong>only</strong> ever use the latter one, 
and that is that the <code>==</code> does <strong>type coercion</strong> which results in the following:</p>

<pre><code>""           ==   "0"           // false
0            ==   ""            // true
0            ==   "0"           // true
false        ==   "false"       // false
false        ==   "0"           // true
false        ==   undefined     // false
false        ==   null          // false
null         ==   undefined     // true
" \t\r\n"    ==   0             // true
</code></pre>

<p>As you can see from this mess, there's absoulutely no <strong>good</strong> reason to use the 
<code>==</code> operator. All that type coercion does is, to introduce hard to track down
errors due to implicit conversion of types.</p>

<p>There's also a performance impact when type coercion is in play. So <code>==</code> might
end up being a lot slower, while <code>===</code> on the other hand, is always <em>at least</em> as 
fast as <code>==</code> or faster, when the types are identical.</p>

<p><strong>Best Practice:</strong> Always, always use <code>===</code> there is never a good reason to use
<code>==</code> you will avoid a lot of potentionl bugs this way, in cases where you need
to coerce types, do it explicitly.</p></div><h3 class="section" id="null-and-undefined">Null and Undefined<a href="#top">^</a></h3><div class="sub"><p>There's some confusion about what those two values are used for.</p>

<p><code>undefined</code> is just a type, but there's also the <em>variable</em> <code>undefined</code> which 
defaults to the value of <code>undefined</code> but its value <strong>can</strong> be changed. All 
variables that have not been assigned any value, default to the <em>value</em> 
<code>undefined</code>.</p>

<p>In the case of unsupplied function arguments <em>or</em> when trying to access 
properties of an object which aren't defined on the object itself and cannot be 
found by searching the prototype chain either, JavaScript will also return 
the value <code>undefined</code>. </p>

<p>To procect oneself against changes to the value of the variable <code>undefined</code>, you
can get a <em>new</em> one by having an extra argument on your anyonymous wrapper
function, for which you <em>don't</em> pass a value:</p>

<pre><code>(function(undefined) {
    // now we have a fresh version of the undefined variable

})(); // don't pass any value so that the argument defaults to undefined
</code></pre>

<p>The <code>null</code> is both a literal and a type.</p>

<p>While <code>null</code> is used a lot in the interals of objects and can at many places be
used in exchange with <code>undefined</code>, it's mostly just another data type when it
comes to JavaScript programming.</p></div><h3 class="section" id="automatic-semicolon-insertion">Automatic Semicolon Insertion<a href="#top">^</a></h3><div class="sub"><p>The JavaScript parser allows for ommitting semicolons, since they're still 
needed, it will automatically replace newlines (<code>\n</code>) with <code>;</code> as soon as it
encounters a parse error due to a missing semicolon.</p>

<p><strong>Example</strong></p>

<pre><code>return
{
    foo: 1
}
</code></pre>

<p>This will <strong>not</strong> return an object which has a property called <code>foo</code>, it will
instead simply return <code>undefined</code>.</p>

<p><strong>How the parser "fixes" it</strong></p>

<pre><code>return // parse error, expected a semicolon, automatic insertion happens
{ // while JS has no block scope, it handles blocks just fine
    foo: 1 // this doesn't break either, foo is seen as a label here
           // JavaScript does support single expression evaluation so 
           // the number evaluates to 1 just fine

} // another automatic insertion of a semicolon happens here
</code></pre>

<p><strong>The results</strong></p>

<pre><code>return;
// dead code
{
    foo: 1
};
</code></pre>

<p>This is the <strong>number one</strong> reason to have your <code>{}</code> always on the <strong>same</strong> line
and to <strong>never</strong> use the short hand syntax of omitting the curly braces for one
line <code>if / else</code> statements.</p></div></div>
    </body>
</html>

<!DOCTYPE HTML>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
        <title>JavaScript Garden</title>
        <link rel="stylesheet" href="garden.css" type="text/css" media="screen" charset="utf-8">
    </head>

    <body id="top">
        <div id="nav"><h1>Gardening Topics</h1><div id="navbox"><div><a href="#objects">Objects</a></div><div><a href="#the-prototype">The Prototype</a></div><div><a href="#hasownproperty">hasOwnProperty</a></div><div><a href="#the-for-in-loop">The For In Loop</a></div><div><a href="#arrays">Arrays</a></div><div><a href="#the-array-constructor">The Array Constructor</a></div><div><a href="#functions-and-statements">Functions and Statements</a></div><div><a href="#closures-and-references">Closures and References</a></div><div><a href="#function-arguments">Function Arguments</a></div><div><a href="#scopes-and-namespaces">Scopes and Namespaces</a></div><div><a href="#how-this-works-in-javascript">How this works in JavaScript</a></div><div><a href="#constructors">Constructors</a></div><div><a href="#the-typeof-operator">The typeof operator</a></div><div><a href="#the-instanceof-operator">The instanceof operator</a></div><div><a href="#equality-in-javascript">Equality in JavaScript</a></div><div><a href="#null-and-undefined">Null and Undefined</a></div><div><a href="#automatic-semicolon-insertion">Automatic Semicolon Insertion</a></div></div><div id="footer"><p>Copyright (c) 2011 Ivo Wetzel</p></div> </div>
        <div id="main"><h1>JavaScript Garden</h1><p><strong>JavaScript Garden</strong> is a collection of documentation about the most quirky
parts of the JavaScript language. </p><h3 class="section" id="objects">Objects<a href="#top">^</a></h3><div class="sub"><p>Everything in JavaScript - except for <code>null</code> and <code>undefined</code> -  <strong>acts</strong> like an 
<code>Object</code>. This means that all types inherit from <code>Object.prototype</code> (yet another 
reason <strong>not</strong> to mess with it).</p>

<p><strong>Examples</strong></p>

<pre><code>false.toString() // 'false'
[1, 2, 3].toString(); // '1,2,3'
2.toString(); // syntax error
</code></pre>

<p>The last example doesn't work, but this is <strong>not</strong> because the number literal 
cannot be used like an object, it's because of a mis-design in JavaScript's 
parser. Which tries to parse <strong>anything</strong> that follows a dot - which itself is 
preceded by whitespace or a number literal - as a floating point number.</p>

<p>You can work around this by either inserting a space <code>2. toString()</code>, another dot
<code>2..toString()</code> or using parenthesis <code>(2).toString()</code>.</p>

<p>Objects can also <strong>act</strong> like a hashmap in JavaScript by simply mapping <em>keys</em> to
<em>values</em>. Using the curly brace notation <code>{}</code> one can create a new plain object, 
which inherits from <code>Object.prototype</code> and has no <a href="#hasownproperty">own
properties</a>.</p>

<p><strong>Example</strong></p>

<pre><code>var foo = {}; // a new empty object
var bar = {test: 12}; // a new object which has one property called 'test'
                      // which value is 12

var test = {
    delete: function() {}
};
</code></pre>

<p>The above definition of <code>test</code> raises a <code>SyntaxError</code> in JavaScript engines which 
do not support the upcoming EcmaScript 5 standard. What happens is that <code>delete</code> 
is a <em>keyword</em> and therefore cannot be used as a key here (another mis-design of
the  parser). But you can simply work around this by using a string with the 
value of <code>'delete'</code> instead of the plain literal.</p></div><h3 class="section" id="the-prototype">The Prototype<a href="#top">^</a></h3><div class="sub"><p>JavaScript does not feature the classical inheritance model, instead it uses a 
<em>prototypical</em> one. This might at first seem like a limitation, but it's not. a 
<em>prototypical</em> inheritance model is in fact more powerful than the classical
one, for example you can emulate the classical model with it, but you can't do it
the other way around.</p>

<p>Due to the fact that JavaScript is practically the only language in that's both in
widespread <strong>and</strong> uses prototypical inheritance, it takes some time to adjust
to the differences between the two models. Inheritance in JavaScript is done by
using <em>prototype chains</em>.</p>

<p><strong>Example</strong></p>

<pre><code>function Foo() {
    this.value = 42;
}
Foo.prototype = {
    method: function() {
    }
};

function Bar() {
}

// Set Bar's prototype to the prototype object of Foo
Bar.prototype = Foo.prototype;

var test = new Bar() // create a new bar instance
</code></pre>

<p>The above <code>test</code> object will inherit from both <code>Bar.prototype</code> and
<code>Foo.prototype</code>, so it will have access to the function <code>method</code> that was defined
on <code>Foo</code>, but it will not have access to the value property of a <code>Foo</code> instance
since <code>Foo</code> itself never gets called.  </p>

<blockquote>
  <p><strong>Note:</strong> Don't use <code>Bar.property = Foo;</code> this will <strong>not</strong> point to <code>Foo</code> its
prototype (therefore <code>method</code> is not on the prototype chain), but rather to the 
function object <code>Foo</code>, so the chain will go over <code>Function.prototype</code> in this 
case.</p>
</blockquote>

<p>If you try to access a property of an <code>Object</code>, JavaScript will traverse the
prototype chain <strong>upwards</strong> until it finds a property with the specified name.
When it reaches the top of the chain - namely <code>Object.prototype</code> - and still
hasn't found the property it will return the value <code>undefined</code>.</p>

<p><strong>The Prototype Chain in the above Example</strong></p>

<pre><code>Object.prototype: {toString: ... /* etc. */};
    Foo.prototype: {method: ...};
        Bar.prototype: Foo.prototype
            Bar.method()
</code></pre>

<p>You can actually assign <strong>any</strong> <code>object</code> to the <code>prototype</code> property, so consider
the following.</p>

<p><strong>Example</strong></p>

<pre><code>Bar.prototype = new Foo();
var boo = new Bar();
</code></pre>

<p><strong>The resulting prototype chain</strong></p>

<pre><code>Object.prototype: {toString: ... /* etc. */};
    Foo.prototype: {method: ...};
        [Foo Instance]: {value: 42};
            Bar.prototype: [Foo Instance]
                Bar.method()
</code></pre>

<p>Now <code>Bar.prototype</code> points to an <strong>instance</strong> of <code>Foo</code>, which of course is just
another object, but this time has the <code>value</code> property defined on it. And since 
<code>Foo</code> itself has a prototype, the chain continues with that one afterwards.</p>

<p>As a result of this, the lookup time for properties that are high up the chain 
can have a negative impact on performance critical code. Access to non existent
properties will always traverse the full chain and when 
<a href="#the-for-in-loop">iterating</a> over the properties of an <code>Object</code> <strong>every</strong> 
property that's on the <code>prototype</code> chain will get enumerated.</p>

<h4>Best Practices</h4>

<p>Make sure to that you understand the prototypical inheritance model completely,
otherwise you will end up with unexpected, seemingly surprising results. Also,
watch the prototype chains of your objects, remember that they can have a big
impact on performance when not used correctly.</p></div><h3 class="section" id="hasownproperty">hasOwnProperty<a href="#top">^</a></h3><div class="sub"><p>If you want to check whether a <code>Object</code> has a property defined on <strong>itself</strong> (and 
not just somewhere on the <a href="#the-prototype">prototype chain</a>, you have to use the 
<code>hasOwnProperty</code> method which all objects inherit from <code>Object.prototype</code>.</p>

<p>While it is tempting to just do a <code>Foo.bar !== undefined</code> this is in no way safe.
Although JavaScript does return <code>undefined</code> for non-existent properties, they
property might very well exist, but it's value just happens to be set to 
<code>undefined</code>.</p>

<p>Additionally, using the <code>in</code> operator doesn't work either, since it <strong>does</strong> 
traverse the prototype chain upwards until it finds a property with the 
specified name.</p>

<p><strong>Example</strong></p>

<pre><code>// Poisoning Object.prototype, NEVER do this, it calls for trouble
Object.prototype.bar = 1; 
var foo = {goo: undefined};

foo.bar; // 1
'bar' in foo; // true

foo.hasOwnProperty('bar'); // false
foo.hasOwnProperty('goo'); // true
</code></pre>

<p>As you can see, only <code>hasOwnProperty</code> gives the correct and expected result. 
<code>hasOwnProperty</code> is of essential use when iterating over the properties of any 
<code>Object</code>, since there's no other way to exclude things that are not defined on 
the object <strong>itself</strong> but rather somewhere on its prototype chain.  </p>

<h4>Best Practices</h4>

<p>Always use <code>hasOwnProperty</code> when checking for the existence of properties on an 
<code>Object</code> and even more important, make sure that <code>hasOwnProperty</code> is part of 
<strong>every</strong> <a href="#the-for-in-loop">for in loop</a> you write.</p></div><h3 class="section" id="the-for-in-loop">The For In Loop<a href="#top">^</a></h3><div class="sub"><p>Just like the <code>in</code> operator, the <code>for in</code> loop does also traverse the prototype
chain when iterating over the properties of an <code>Object</code>.</p>

<blockquote>
  <p><strong>Note:</strong> The <code>for in</code> loop it will <strong>not</strong> iterate over any properties that have
their <code>enumerable</code> attribute set to <code>false</code>, for example the <code>length</code>property of 
an <code>Array</code>.</p>
</blockquote>

<p>Since you cannot change the behavior of the <code>for in</code> loop itself, you have to
filter out the unwanted properties in the loop body by using 
<a href="#hasownproperty"><code>hasOwnProperty</code></a>. It should also be noted that due to its
nature of traversing the complete prototype chain, the <code>for in</code> loop can get
incredible slow for complex inheritance structures.</p>

<p><strong>Example</strong></p>

<pre><code>Object.prototype.bar = 1; // poisoning the Object.prototype, NEVER do this
var foo = {moo: 2};
for(var i in foo) {
    console.log(i);
}
</code></pre>

<p>The above code results in both <code>bar</code> and <code>moo</code> being printed out.</p>

<p><strong>Example</strong></p>

<pre><code>for(var i in foo) { // still the foo from above
    if (foo.hasOwnProperty(i)) {
        console.log(i);
    }
}
</code></pre>

<p>This version is the only correct one, it will <strong>only</strong> print out <code>moo</code>. If you 
don't use  <code>hasOwnProperty</code>, your code is prone to errors when the native 
prototypes - for example <code>Object.prototype</code> have been extended.</p>

<p>One widely used Framework which does this, is <strong>Prototype.js</strong>. If your code ever
ends up on a site which includes that Framework, and it does <strong>not</strong> use
<code>hasOwnProperty</code>, it is basically <strong>guaranteed</strong> to break.</p>

<h4>Best Practices</h4>

<p>Always use <code>hasOwnProperty</code>. Never make any assumptions on the built in 
prototypes being extended or not. </p></div><h3 class="section" id="arrays">Arrays<a href="#top">^</a></h3><div class="sub"><p>Although the <code>Array</code> in JavaScript is an <code>Object</code>, there's no good reason to use
the <a href="#the-for-in-loop">for in loop</a> in order to iterate over it. In fact there
a number of very good reasons <strong>against</strong> the use of <code>for in</code> on an <code>Array</code>.</p>

<p>While it may seem like a good choice at first, to trade the some speed against
the readability of the <code>for in</code> construct, this has <strong>major</strong> implications on
performance.</p>

<p>The <code>for in</code> does in fact iterate over the indexes of an <code>Array</code>. But it does
also traverse the prototype chain. So one already has to use <code>hasOwnProperty</code> in
order to make sure to filter out unwanted properties, and still if any
additional properties happen to be defined on the array, they will still make it
through this filter.</p>

<p>Combining the already slow nature of the prototype traversing <code>for in</code> with the
use of <code>hasOwnProperty</code> results in a performance degradation of a factor of up
to <strong>20x</strong>.</p>

<p>So if you want to iterate over an <code>Array</code> in JavaScript, <strong>always</strong> use the
classic <code>for</code> loop construct.</p>

<p><strong>Example</strong></p>

<pre><code>var list = [1, 2, 3, 4, 5, ...... 100000000];
for(var i = 0, l = list.length; i &lt; l; i++) {
    console.log(list[i]);
}
</code></pre>

<p>As you can see, there's one extra catch in the above example. That is the
caching of the length via <code>l = list.length</code>.</p>

<p>Although the <code>length</code> property is defined on the array itself, there's still an
overhead for doing the lookup on each iteration. And while recent JavaScript
engines <strong>may</strong> apply optimization in this case, one can never be sure that
those optimizations are actually in place, nor can one be sure whether they
reach the speed of the above caching. In fact leaving out the caching may result
in a performance degradation of a factor of up to <strong>2x</strong> (and even more in older
engines).</p>

<p>The <code>length</code> property of an <code>Array</code> is not just a plain property. While its 
<code>getter</code> just returns the number of elements in the array, its <code>setter</code> on 
the other hand can be used to <strong>truncate</strong> the array.</p>

<p><strong>Example</strong></p>

<pre><code>var foo = [1, 2, 3, 4, 5, 6];
foo.length = 3;
foo; // [1, 2, 3]
foo.length = 6;
foo; // [1, 2, 3]
</code></pre>

<p>As one can see, assigning a smaller length truncates the array, but increasing 
the length it has no effect at all.</p>

<h4>Best Practices</h4>

<p>Always use the <code>for</code> construct and cache the length to achieve the best 
performance, don't make any assumptions about the JavaScript engine optimizing 
<strong>anything</strong>.</p></div><h3 class="section" id="the-array-constructor">The Array Constructor<a href="#top">^</a></h3><div class="sub"><p>Always use the <code>[]</code> notation to create a new array, the <code>Array</code> is ambiguous in 
how it deals with its parameters.</p>

<p><strong>Example</strong></p>

<pre><code>[1, 2, 3]; // Result: [1, 2, 3]
new Array(1, 2, 3); // Result: [1, 2, 3]

[3]; // Result: [3]
new Array(3); // Result: [undefined, undefined, undefined] 
new Array('3') // Result: ['3']
</code></pre>

<p>When there's only one argument being passed to the <code>Array</code> constructor and that
argument is a <code>Number</code>, the constructor will use that number as the length of
the new array to be create.</p>

<p>There are only a few cases when the above behaviour comes in handy, on of them is
to repeat a string:</p>

<pre><code>new Array(count - 1).join(stringToRepeat);
</code></pre>

<h4>Best Practices</h4>

<p>Always use the <code>[]</code> notation, not only is is shorter and easier to read, it's
also consistent in its behavior. If you see code that uses the <code>Array</code>
constructor without any good reason, that a clear sign that somethings wrong.</p></div><h3 class="section" id="functions-and-statements">Functions and Statements<a href="#top">^</a></h3><div class="sub"><p>Functions in JavaScript are first class objects, that means they can be passed
around like any other value. One common use of that feature is to pass
<em>anonymous funtions</em> as callbacks to other functions. </p>

<p>There are a two of different ways do define functions in JavaScript.</p>

<p><strong>The Function Statement</strong></p>

<pre><code>function foo() { 
}
</code></pre>

<p>The above function gets created <strong>before</strong> any actual code is run, therefore its
available everywhere in the scope it was defined in from the start.</p>

<p><strong>Example</strong></p>

<pre><code>foo(); // Works because foo was created before this code runs
function foo() {
}
</code></pre>

<p><strong>The Function Expression</strong></p>

<pre><code>var foo = function() {
};
</code></pre>

<p>The above assign the unnamed and therefore <em>anonymous</em> function to the variable
<code>foo</code>. But it does <strong>not</strong> do so before the code is run. </p>

<p><strong>Example</strong></p>

<pre><code>foo; // 'undefined'
foo(); // this raises a TypeError
var foo = function() {
};
</code></pre>

<p>The above may seem strange at first, but <code>var</code> is a statement, so the variable
<code>foo</code> will once again get created before any code is run. But <code>=</code> is an
expression, therefore <code>foo</code> does not get assigned any value, so it defaults to 
<code>undefined</code>.</p>

<p><strong>The var Statement</strong></p>

<pre><code>function test() {
    if (foo) {
        bar = 2;

    } else {
        var bar = 1;
    }
    return foo;
}

if (false) {
    var foo = 1;
}
</code></pre>

<p>Since there's <strong>no</strong> <a href="#scopes-and-namespaces">block scope</a> in JavaScript, the above will
<strong>not</strong> assign the value <code>2</code> to the <em>global</em> variable <code>bar</code>, rather it assigns it to the 
<em>local</em> variable <code>bar</code> of <code>test</code>. Also, while the if body never gets executed, 
the variable <code>foo</code> still gets created and defaults to <code>undefined</code>.</p></div><h3 class="section" id="closures-and-references">Closures and References<a href="#top">^</a></h3><div class="sub"><p>One of JavaScript's most powerful features is the availability of <em>Closures</em>.
But it's also one of its most misunderstood features.</p>

<p>Closures mean that scopes <strong>always</strong> keep access to the outer scope they were
defined in. Since JavaScript only has one type of scope - the function scope - 
all functions are by technically closures,</p>

<p>Although the word closure is most commonly used to refer to functions that were 
either returned or passed as an argument.</p>

<p><strong>Example</strong></p>

<pre><code>function Counter(start) {
    var count = start;
    return {
        increment: function() {
            count++;
        },

        get: function() {
            return count;
        }
    }
}

var foo = new Counter(4);
foo.increment();
foo.get(); // 5
</code></pre>

<p>In the above example we return <strong>two closures</strong>. The function <code>increment</code> as well
as the function <code>get</code>, both keep a <em>reference</em> to the scope of  <code>Counter</code> and 
therefore always have access to the <code>count</code> variable that was defined in <strong>that</strong>
scope.</p>

<p>Since it's not possible to reference or assign scopes, there's <strong>no</strong> way one 
could access the variable <code>count</code> from the outside, the only way to interact with it
is via the two "closured" functions. Therefore <code>count</code> is essentially private.</p>

<p><strong>Example</strong></p>

<pre><code>var foo = new Counter(4);
foo.hack = function() {
    count = 1337;
};
</code></pre>

<p>This will <strong>not</strong> change the variable <code>count</code> in the scope of <code>Counter</code> since 
<code>foo.hack</code> was not defined in that scope, instead, it will create or override the
<em>global</em> variable <code>count</code>.</p>

<p>A common mistake made with Closures is not to understand that they keep
a reference to the scope, and not the variables. It's especially important to
understand that they do <strong>not</strong> copy the values of primitives.</p>

<p><strong>Example</strong></p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout(function() {
        console.log(i);  
    }, 1000);
}
</code></pre>

<p>A common misconception is that the above will output the numbers <code>0</code> through
<code>9</code> after one second. But in reality, the above simply alerts the number <code>10</code> ten
times.</p>

<p>The <em>anonymous</em> function keeps a reference to <code>i</code> and at the time the timeouts 
fire, the loop has already finished and updated the value of <code>i</code> to <code>10</code>.</p>

<p>In order to get the desired behavior, one has to create a copy of the value of 
<code>i</code>. Don't bother with another variable inside the loop, its value will just as 
well get overridden. The trick here is to use an <a href="#scopes-and-namespaces">anonymous
wrapper</a>.</p>

<p><strong>Example</strong></p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    (function(e) {
        setTimeout(function() {
            console.log(e);  
        }, 1000);
    })(i);
}
</code></pre>

<p>Here the outer function gets called immediately with <code>i</code> (which is passed by 
value) as its first arguments, therefore we now have a copy of the <strong>value</strong> of 
<code>i</code> (named <code>e</code>) inside the function</p>

<p>The anonymous function passed to <code>setTimeout</code> now has a reference to <code>e</code> which
does not get changed by the loop.</p>

<h4>Best Practices</h4>

<p>Understand Closures <strong>and</strong> master them, they are the most powerful feature of
JavaScript. If you're not able to use them correctly you're wasting a lot of the
language's potential.</p></div><h3 class="section" id="function-arguments">Function Arguments<a href="#top">^</a></h3><div class="sub"><p>Inside a JavaScript function you have access to a special variable called
<code>arguments</code>, which is a list of the parameters the function was called with. This 
is useful when writing functions that deal with variable number of arguments. </p>

<p>It's important to know that <code>arguments</code> is <strong>not</strong> an <code>Array</code>, it has some of
the semantics of an array - namely the <code>length</code> property - but it does not
inherit from <code>Array.prototype</code>, it is an <code>Object</code>.</p>

<p>Due to this fact, one cannot use the standard array methods like <code>push</code>, <code>pop</code>,
<code>slice</code> etc. with it. While iteration with a plain <code>for</code> loop works just fine,
one has convert it to a real <code>Array</code> in order to use the named methods.</p>

<pre><code>Array.prototype.slice.call(arguments);
</code></pre>

<p>This will return a new <code>Array</code> containing all the elements from the <code>arguments</code>
object, note that this is <strong>slow</strong>, try to avoid at all costs in performance
critical code. </p></div><h3 class="section" id="scopes-and-namespaces">Scopes and Namespaces<a href="#top">^</a></h3><div class="sub"><p>Although JavaScript deals fine with the block scope syntax of two matching curly
braces, it does <strong>not</strong> support block scope. Therefore all that's left is <em>function
scope</em>.</p>

<blockquote>
  <p><strong>Note:</strong> When not used in an assignment or as a function argument, the <code>{...}</code>
notation will get interpreted as a block statement and <strong>not</strong> as an <code>Object</code>. 
This, in conjunction with 
<a href="#automatic-semicolon-insertion">automatic insertion of semicolons</a>, can lead
to subtle errors.</p>
</blockquote>

<p>Additionally, there are no distinct namespaces in JavaScript, this means that 
everything gets defined in <strong>one</strong> globally shared namespace.</p>

<p>Each time one references a variable, JavaScript will traverse through the scopes 
upwards until it finds it. In the case that it reaches the global scope and still 
can't find the requested name it will raise a <code>ReferenceError</code>.</p>

<p>If one wants to declare a variable <em>local</em> to the current scope thes have to use 
the <code>var</code> keyword. <strong>Always</strong> use the <code>var</code> keyword when declaring variables
otherwise you might <strong>overriding</strong> things that were already defined in outer
scopes.</p>

<p><strong>Example</strong></p>

<pre><code>// global scope
var foo = 1;
var bar = 2;

function test() {

    // local scope of the function test
    var foo = 3;
    bar = 4;
}
</code></pre>

<p>In the above, <code>var foo</code> inside of <code>test</code> will create a new variable that is in
the <em>local</em> scope. Therefore the value of the <em>global</em> <code>foo</code> does <strong>not</strong> get
changed. But the assignment <code>bar = 4</code> will override the value of the <em>global</em>
<code>bar</code> due to the missing <code>var</code> keyword.</p>

<p>Having only one global namespace calls for clashes of variable names, luckily
with the help of <em>anoynmous function wrappers</em> one can create his own namespace.</p>

<p><strong>Example</strong></p>

<pre><code>(function() {
    // a self contained "namespace"

    window.foo = function() {
        // an exposed closure
    };

})(); // execute the function immediately
</code></pre>

<p>By default you cannot just call a function, you need to <strong>evaluate</strong> it first. 
In this example, this is done by wrapping the 
<a href="#functions-and-statements">function expression</a> in parenthesis. While this is 
the most common style to do this, everything else that forces the function to be 
evaluated works just as well, like for example <code>+function(){}()</code>.</p>

<h4>Best Practices</h4>

<p>Always use the <em>anonymous wrapper</em> to encapsulate your code in case there's any 
chance it might get used by someone else in their project. Also never define any 
variables in the <em>global namespace</em>, always use <code>var</code> to limit the scope of your 
variables.</p></div><h3 class="section" id="how-this-works-in-javascript">How this works in JavaScript<a href="#top">^</a></h3><div class="sub"><p>JavaScript has a, at first, very strange concept of what <code>this</code> refers to.
There are exactly five different ways in which the value of <code>this</code> can get set.</p>

<p><strong>The Global Case</strong></p>

<pre><code>this;
</code></pre>

<p>When using <code>this</code> in global scope, it will simply refer to the <em>global</em> object.</p>

<p><strong>The Function Case</strong></p>

<pre><code>foo();
</code></pre>

<p>Here <code>this</code> will again refer to the <em>global</em> object.</p>

<p><strong>The Method Case</strong></p>

<pre><code>test.foo();
</code></pre>

<p>In this example <code>this</code> will refer to <code>test</code>.</p>

<p><strong>The Constructor Case</strong></p>

<pre><code>new foo();
</code></pre>

<p>A function call that's preceded by the <code>new</code> keyword acts as
a <a href="#constructors">constructor</a>. Inside the function <code>this</code> will refer to a newly
created <code>Object</code>.</p>

<p><strong>The Explicit Case</strong></p>

<pre><code>function foo(a, b, c) {
}

var bar = {};
foo.call(bar, [1, 2, 3]);
foo.apply(bar, 1, 2, 3);
</code></pre>

<p>When using the <code>call</code> or <code>apply</code> methods of <code>Function.prototype</code>, one can 
explictly set the value of <code>this</code> inside the called function, so in the above
case the <em>method case</em> does <strong>not</strong> apply, and <code>this</code> inside of <code>foo</code> will be
set to <code>bar</code>.</p>

<blockquote>
  <p><strong>Note:</strong> <code>this</code> <strong>cannot</strong> be used to refer to the object inside of an <code>Object</code>
literal. So <code>var obj = {me: this}</code> will <strong>not</strong> result in <code>me</code> refering to
<code>obj</code>, since <code>this</code> gets determined by one of the above cases.</p>
</blockquote>

<p>While most of these cases make sense, the first one is considered a mis-design 
by many people since it's <strong>never</strong> of any practical use, but leads to many bugs.</p>

<p><strong>Example</strong></p>

<pre><code>Foo.method = function() {
    function test() {
        // this is set to the global object
    }
    test();
}
</code></pre>

<p>A common misconception is that <code>this</code> inside of <code>test</code> refers to <code>Foo</code>, but it 
does <strong>not</strong>.</p>

<p>In order to gain access to <code>Foo</code> from within <code>test</code> one has to create a local
variable inside of <code>method</code> which refers to <code>Foo</code>.</p>

<p><strong>Example</strong></p>

<pre><code>Foo.method = function() {
    var that = this;
    function test() {
        // Use that instead of this here
    }
    test();
}
</code></pre>

<p><code>that</code> is just a normal name, but it's a common idiom to use it as a reference
to an outer <code>this</code>. In combination with <a href="#closures-and-references">Closures</a>, 
this can also be used to pass <code>this</code> around.</p>

<p>Another thing that does <strong>not</strong> work in JavaScript is binding a method to
a variable.</p>

<p><strong>Example</strong></p>

<pre><code>var test = someObject.methodTest();
test();
</code></pre>

<p>Again due to the first case, <code>test</code> now acts like like a plain function call
therefore the <code>this</code> inside it will not refer to <code>someObject</code> anymore.</p>

<p>While the late binding of <code>this</code> might seem like a bad thing, it is fact what
makes <a href="#the-prototype">prototypical inheritance</a> work. </p>

<p><strong>Example</strong></p>

<pre><code>function Foo() {}
Foo.prototype.method = function() {};

function Bar() {}
Bar.prototype = Foo.prototype;

new Bar().method();
</code></pre>

<p>When <code>method</code> gets called on a instance of <code>Bar</code>, <code>this</code> will now refer to that
instance.  </p>

<h4>Best Practices</h4>

<p>Don't try to work around the behavior of <code>this</code> in JavaScript. Instead
<strong>understand</strong> how and why it works the way it does. Otherwise you'll end up with
a lot of bugs that seem to be there for no good reason.</p></div><h3 class="section" id="constructors">Constructors<a href="#top">^</a></h3><div class="sub"><p>Constructors in JavaScript are another thing many people get wrong, their
workings are pretty simple though.</p>

<p>Any function call that's preceded by the <code>new</code> keyword acts as a constructor.</p>

<p>Inside the constructor (the called function) the value of <code>this</code> refers to a 
newly created <code>Object</code>. The <code>prototype</code> of this <strong>new</strong> object is set to the 
<code>prototype</code> of the function object that was called.</p>

<p>If the function that was called has no explicit <code>return</code> statement, then it
implicitly returns the value of <code>this</code> (the new object). Otherwise it returns
the value of the <code>return</code> statement.</p>

<p><strong>Example</strong></p>

<pre><code>function Foo() {
    this.bla = 1;
}
Foo.prototype.test = function() {
    console.log(this.bla);
};

var test = new Foo();
</code></pre>

<p>The above calls <code>Foo</code> as constructor and sets the <code>prototype</code> of the newly
created object to <code>Foo.prototype</code>.</p>

<p>Keep in mind that if you don't use the <code>new</code> keyword the function will <strong>not</strong>
return a new object. While it might still work due to the fact how
<a href="#how-this-works-in-javascript">this</a> works in JavaScript, it will use the
<em>global</em> object as the value of <code>this</code> and therefore result in completely
unexpected results.</p>

<p>If you want to omit the <code>new</code> keyword you can do that by - as stated above
- explicitly returning from the constructor.</p>

<p><strong>Example</strong></p>

<pre><code>function Bar() {
    var value = 1;
    return {
        method: function() {
            return value;
        }
    }
}

new Bar();
Bar();
</code></pre>

<p>Now, both these calls return the exact same thing, a newly create object which
has a property called <code>method</code> which is a <a href="#closures-and-references">Closure</a>.</p>

<p>Since <code>Bar</code> doesn't make any use of <code>this</code>, the <code>new</code> keyword is superfluous
here. But from a technical point of view, this is no longer a <em>constructor</em>, but
a <em>factory</em>.</p>

<h4>Best Practices</h4>

<p>Make sure you know whether you're calling a <em>constructor</em> or a <em>factory</em>. 
If in doubt, always use the <code>new</code> keyword, since it doesn't have any side effect
when its not required, leaving it out on the other hand can lead to subtle and
hard to track down bugs.</p></div><h3 class="section" id="the-typeof-operator">The typeof operator<a href="#top">^</a></h3><div class="sub"><p>The <code>typeof</code> operator (together with 
<a href="#the-instanceof-operator">instanceof operator</a>) is probably the biggest 
design flaw of JavaScript. It is near of being <strong>completely broken</strong>.</p>

<p>Although <code>instanceof</code> still has its limited uses, <code>typeof</code> really has only one
practical use case, which <strong>not happens</strong> to be checking the type of an object. </p>

<blockquote>
  <p><strong>Note:</strong> While <code>typeof</code> can also be called with a function like syntax
i.e. <code>typeof(obj)</code>, this is just syntactic sugar. There is <strong>no</strong>
<code>typeof</code> function.</p>
</blockquote>

<p><strong>The JavaScript Typetable</strong></p>

<pre><code>Value               Class      Type
-------------------------------------
"foo"               String     string
new String("foo")   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function("")    Function   function
/abc/g              RegExp     object (function in Nitro/V8)
new RegExp("meow")  RegExp     object (function in Nitro/V8)
{}                  Object     object
new Object()        Object     object
</code></pre>

<p>In the above table <em>Type</em> refers to the value the <code>typeof</code> operator returns. As
you can see this is anything but consistent.</p>

<p>The <em>Class</em> refers to the value of the internal <code>[[Class]]</code> property of an object.</p>

<blockquote>
  <p><strong>From the Specification:</strong>  <em>Class</em> can be one of the following values: 
<code>"Arguments"</code>, <code>"Array"</code>, <code>"Boolean"</code>, <code>"Date"</code>, <code>"Error"</code>, <code>"Function"</code>,
<code>"JSON"</code>, <code>"Math"</code>, <code>"Number"</code>, <code>"Object"</code>, <code>"RegExp"</code>, <code>"String"</code></p>
</blockquote>

<p>In order to retrieve the value of <em>Class</em> one can has to make use of the
<code>toString</code> method of <code>Object</code>.</p>

<p><strong>Checking the Class of an Object</strong></p>

<pre><code>function is(type, obj) {
    return Object.prototype.toString.call(obj).slice(8, -1) === type;
}

is('String', 'test'); // true
is('String', new String('test')); // true
</code></pre>

<p>In the above code <code>Object.prototype.toString</code> gets called with 
<a href="#how-this-works-in-javascript">this</a> being set to the object which its 
<em>Class</em> value should be retrieved.</p>

<p><strong>Checking whether a variable has been defined</strong></p>

<pre><code>typeof foo !== 'undefined'
</code></pre>

<p>The above will check whether <code>foo</code> was actually declared or not, since just 
referencing it would result in a <code>ReferenceError</code>. This is the only thing
<code>typeof</code> is actually useful for.</p>

<h4>Best Practices</h4>

<p>If you need to check the type of an object, always use the call to
<code>Object.prototype.toString</code> it's the only reliable way of doing so. As shown in
the type table, some return values of <code>typeof</code> are not defined in the
specification and can therefore differ in different implementations. So unless
you're checking for a variable being defined, <strong>do not</strong> use the <code>typeof</code>
operator.</p></div><h3 class="section" id="the-instanceof-operator">The instanceof operator<a href="#top">^</a></h3><div class="sub"><p><code>instanceof</code> is only useful when comparing custom made objects, besides that it
returns a mess similar to the <a href="#the-typeof-operator">typeof operator</a>.</p>

<p><strong>Comparing custom Objects</strong></p>

<pre><code>function Foo() {}
function Bar() {}
Bar.prototype = Foo;

new Bar() instanceof Bar; // true
new Bar() instanceof Foo; // false
</code></pre>

<p><strong>When used on builtin Types</strong></p>

<pre><code>new String('foo') instanceof String; // true
new String('foo') instanceof Object; // true

'foo' instanceof String; // false
'foo' instanceof Object; // false
</code></pre>

<p>Important to note here is that <code>instanceof</code> will <strong>of course</strong> not work when the 
two objects origin from different JavaScript contexts e.g. different documents in
a Web Browser.</p>

<h4>Best Practices</h4>

<p>Only use <code>instanceof</code> when dealing with custom made objects, <strong>never</strong> use it like
the <code>typeof</code> operator it will behave just as bad and even worse when dealing
with objects from different contexts.</p></div><h3 class="section" id="equality-in-javascript">Equality in JavaScript<a href="#top">^</a></h3><div class="sub"><p>JavaScript has two different ways of comparing the values of objects for else
equality. It has both the <code>==</code> <em>double equal</em> operator and the <code>===</code>
<em>triple equal</em> operator.</p>

<p>There is an important difference between those two and a good reason for 
<strong>only</strong> triple version</p>

<p>JavaScript has <em>weak typing</em> and therefore the creators of the language built in
a way of doing <em>type coerion</em> when comparing two values. The only problem is
that, instead of making <em>type coercin</em> optional, they made it the <strong>default</strong>.</p>

<p>So the <code>==</code> operator will try everything that the language spec allows for to
convert the two values to the same type and then compare them.</p>

<p><strong>The Double Equal  Operator</strong> </p>

<pre><code>""           ==   "0"           // false
0            ==   ""            // true
0            ==   "0"           // true
false        ==   "false"       // false
false        ==   "0"           // true
false        ==   undefined     // false
false        ==   null          // false
null         ==   undefined     // true
" \t\r\n"    ==   0             // true
</code></pre>

<p>As you can see from this mess, there's absolutely <strong>no</strong> good reason to use the 
<code>==</code> operator. All that <em>type coercion</em> does is, is to introduce hard to track 
down errors due to implicit conversion of types.</p>

<p>There's also a performance impact when type coercion is in play. So <code>==</code> might
end up being a lot slower, while <code>===</code> on the other hand, is always <strong>at least</strong>
as fast - or faster, when dealing with different types.</p>

<p><strong>The Triple Equal Operator</strong></p>

<pre><code>""           ===   "0"           // false
0            ===   ""            // false
0            ===   "0"           // false
false        ===   "false"       // false
false        ===   "0"           // false
false        ===   undefined     // false
false        ===   null          // false
null         ===   undefined     // false
" \t\r\n"    ===   0             // false
</code></pre>

<p>These are the results one coming from a strongly typed language would expect.</p>

<h4>Best Practices</h4>

<p><strong>Always</strong> <code>===</code> there is never a <strong>any</strong> reason at all to use <code>==</code>. You will 
avoid a lot of potential, yet again, subtle bugs this way. In cases where you 
need to coerce types, do so <strong>explicitly</strong>.</p></div><h3 class="section" id="null-and-undefined">Null and Undefined<a href="#top">^</a></h3><div class="sub"><p>There's some confusion about what those two values are used for.</p>

<p><code>undefined</code> is just a type, but there's also the <em>variable</em> <code>undefined</code> which 
defaults to the value of <code>undefined</code> but its value <strong>can</strong> be changed. All 
variables that have not been assigned any value, default to the <em>value</em> 
<code>undefined</code>.</p>

<p>In the case of unsupplied function arguments <em>or</em> when trying to access 
properties of an object which aren't defined on the object itself and cannot be 
found by searching the prototype chain either, JavaScript will also return 
the value <code>undefined</code>. </p>

<p>To procect oneself against changes to the value of the variable <code>undefined</code>, you
can get a <em>new</em> one by having an extra argument on your anyonymous wrapper
function, for which you <em>don't</em> pass a value:</p>

<pre><code>(function(undefined) {
    // now we have a fresh version of the undefined variable

})(); // don't pass any value so that the argument defaults to undefined
</code></pre>

<p>The <code>null</code> is both a literal and a type.</p>

<p>While <code>null</code> is used a lot in the interals of objects and can at many places be
used in exchange with <code>undefined</code>, it's mostly just another data type when it
comes to JavaScript programming.</p></div><h3 class="section" id="automatic-semicolon-insertion">Automatic Semicolon Insertion<a href="#top">^</a></h3><div class="sub"><p>The JavaScript parser allows for ommitting semicolons, since they're still 
needed, it will automatically replace newlines (<code>\n</code>) with <code>;</code> as soon as it
encounters a parse error due to a missing semicolon.</p>

<p><strong>Example</strong></p>

<pre><code>return
{
    foo: 1
}
</code></pre>

<p>This will <strong>not</strong> return an object which has a property called <code>foo</code>, it will
instead simply return <code>undefined</code>.</p>

<p><strong>How the parser "fixes" it</strong></p>

<pre><code>return // parse error, expected a semicolon, automatic insertion happens
{ // while JS has no block scope, it handles blocks just fine
    foo: 1 // this doesn't break either, foo is seen as a label here
           // JavaScript does support single expression evaluation so 
           // the number evaluates to 1 just fine

} // another automatic insertion of a semicolon happens here
</code></pre>

<p><strong>The results</strong></p>

<pre><code>return;
// dead code
{
    foo: 1
};
</code></pre>

<p>This is the <strong>number one</strong> reason to have your <code>{}</code> always on the <strong>same</strong> line
and to <strong>never</strong> use the short hand syntax of omitting the curly braces for one
line <code>if / else</code> statements.</p></div></div>
    </body>
</html>
